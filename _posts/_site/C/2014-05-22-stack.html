<h2 id="section">栈的定义</h2>
<blockquote>
  <p><strong>栈</strong>是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶。</p>
</blockquote>

<p>由定义我们可以知道栈其实就是一个线性表，前面一篇博客<a href="http://leihuang.net/2014/04/17/List/">线性表</a>中,我们已经详细介绍了线性表。我们得知线性表的两种实现方法，<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。</p>

<p>栈也一样，由两中实现方法：<strong>顺序栈</strong>和<strong>链式栈</strong>。
## 两种实现区别
&gt; <strong>顺序栈</strong>：就是利用数组实现的顺序栈，更流行的方法，唯一的危险可能是我们需要提前声明一个数组的大小。因为删除元素和插入元素都在数组的末端，所以不存在效率低的问题。
&gt; <strong>链式栈</strong>：所有操作都花费常数时间，因为没有哪个函数涉及到栈的大小，但有个缺点就是对于malloc和free调用的开销是昂贵的，push和pop操作都需要用到两者。</p>

<p>从上面我们可以得出：声明一个足够大而不至于浪费太多的空间通常并不困难。所以一般用数组实现会更高效，如果你连这点都做不到的话就用链式表来实现。
## 实现源码
具体实现方法就不多说了，这个一定要亲自试试的，如果做不出，在看源码。下面我直接给出两者的实现。</p>

<h3 id="section-1">顺序栈源码:</h3>
<p>```c
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>*
	&gt; File Name: stackarray.c
	&gt; Author: huanglei
	&gt; Mail: huanglei2109@gmail.com 
	&gt; Created Time: 2014年05月20日 星期二 16时17分23秒
    &gt; 用数组实现栈
 <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>/</p>

<h1 id="includestdioh">include<stdio.h></stdio.h></h1>
<p>#include<stdlib.h></stdlib.h></p>

<h1 id="define-minstacksize-5">define MinStackSize 5</h1>
<p>typedef void* ElemType ;
struct Node ;
typedef Node* Stack ;
struct Node
{
    int Capacity ;       //数组最大容量
    int TopOfStack ;        //栈顶，即数组最后一个元素的索引
    ElemType * Array ;   //动态数组
};</p>

<p>int IsEmpty(Stack s) ;
void MakeEmpty(Stack s) ;
Stack CreateStack(int MaxElemNum) ;
int IsFull(Stack s) ;
void DisposeStack(Stack s) ;
void Push(ElemType e,Stack s) ;
ElemType Top(Stack s) ;
void Pop(Stack s) ;
ElemType TopAndPop(Stack s) ;
void PrintStack(Stack s) ;</p>

<p>main()
{
    Stack s ;
    s = CreateStack(10) ;
    if(IsEmpty(s))
        printf(“hi! I ma empty!\n”) ;</p>

<pre><code>int i = 1 ;
int j = 2 ;
int k = 3 ;
int l = 4 ;
Push(&amp;i,s) ;
Push(&amp;j,s) ;
Push(&amp;k,s) ;
Push(&amp;l,s) ;

PrintStack(s) ;
printf("\n") ;
Pop(s) ;

PrintStack(s) ;
printf("\n") ;

printf("the top of stack is %d\n",*(int*)TopAndPop(s)) ;

MakeEmpty(s) ;

PrintStack(s) ;
</code></pre>

<p>}</p>

<p>int IsEmpty(Stack s)
{
    return s-&gt;TopOfStack==-1 ;
}</p>

<p>Stack CreateStack(int MaxElemNum)
{
    Stack s ;
    if(MaxElemNum&lt;MinStackSize){
        printf(“stack size is too small !”) ;
        exit(-1) ;
    }
    s = (Stack)malloc(sizeof(Stack)) ;
    if(s==NULL){
        printf(“out of stack!”) ;
        exit(-1) ;
    }</p>

<pre><code>/* init stack Array,Capacity,TopOfStack */
s-&gt;Array = (ElemType*)malloc(sizeof(ElemType)*MaxElemNum) ;
if(s-&gt;Array==NULL){
    printf("out of stack!") ;
    exit(-1) ;
}
s-&gt;Capacity = MaxElemNum ;
s-&gt;TopOfStack = -1 ; //i.e stack is empty }
</code></pre>

<p>void MakeEmpty(Stack s)
{
    if(s==NULL)
        printf(“you must create stack first!”) ;
    else
        s-&gt;TopOfStack = -1 ;
}</p>

<p>void Pop(Stack s)
{
    if(IsEmpty(s)){
        printf(“stack is empty !”) ;
        exit(-1) ;
    }else
        s-&gt;TopOfStack– ;
}</p>

<p>ElemType TopAndPop(Stack s)
{
    if(IsEmpty(s)){
        printf(“stack is empty!”) ;
        exit(-1) ;
    }
    return s-&gt;Array[s-&gt;TopOfStack–] ;
}</p>

<p>void Push(ElemType e ,Stack s)
{
    if(s-&gt;TopOfStack==s-&gt;Capacity){
        printf(“stack is full!”) ;
        exit(-1) ;
    }else{
        s-&gt;Array[++s-&gt;TopOfStack] = e ;
    }
}</p>

<p>void PrintStack(Stack s)
{
    int i ;
    if(s==NULL)
        printf(“please create Stack first!”) ;
    else if(s-&gt;TopOfStack == -1)
        printf(“stack is empty!”) ;
    else
        for(i=0;i&lt;=s-&gt;TopOfStack;++i)
            printf(“%d-&gt;”,<em>(int</em>)s-&gt;Array[i]) ;
}
```</p>

<h3 id="section-2">链式栈源码</h3>
<p>```c
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>*
	&gt; File Name: stacklist.c
	&gt; Author: huanglei
	&gt; Mail: huanglei2109@gmail.com 
	&gt; Created Time: 2014年05月19日 星期一 21时13分41秒
	&gt; 用链表实现栈
 <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>/</p>

<h1 id="includestdioh-1">include<stdio.h></stdio.h></h1>
<p>#include<stdlib.h>
typedef void* ElemType ;
typedef struct Node
{
    ElemType elem ;
    Node *Next ;
}*Stack ;
/* 栈的函数*/
int IsEmpty(Stack s) ;
Stack CreateStack(void) ;
//void DisposeStack(Stack s) ;
void Push(ElemType x,Stack s) ;
ElemType Top(Stack s) ;
void Pop(Stack s) ;
void MakeEmpty(Stack s) ;</stdlib.h></p>

<p>main()
{
    Stack s ;
    s = CreateStack() ;
    printf(“%d\n”,IsEmpty(s)) ;
    int i = 1 ;
    Push(&amp;i,s) ;
    printf(“%d\n”,<em>(int</em>)Top(s)) ;
    int j = 2 ;
    Push(&amp;j,s) ;</p>

<pre><code>Pop(s) ; 
printf("%d\n",*(int*)Top(s)) ;

MakeEmpty(s) ; }
</code></pre>

<p>int IsEmpty(Stack s)
{
    return s-&gt;Next==NULL ;
}</p>

<p>Stack CreateStack(void)
{
    Stack s ;
    s = (Stack)malloc(sizeof(struct Node)) ;
    if(!s){
        printf(“out of space!”) ;
        exit(-1) ;
    }
    s-&gt;Next = NULL ;
    return s ;
}</p>

<p>void Push(ElemType e,Stack s)
{
    Stack current ;
    current = (Stack)malloc(sizeof(struct Node)) ;
    if(!current){
        printf(“out of space!”) ;
        exit(-1) ;
    }
    current-&gt;elem = e ;
    /* S-&gt;Next指向第一个元素*/
    current-&gt;Next = s-&gt;Next ;
    s-&gt;Next = current ;
}</p>

<p>ElemType Top(Stack s)
{
    return s-&gt;Next-&gt;elem ;
}</p>

<p>void Pop(Stack s)
{
    Stack tmp ;
    if(IsEmpty(s)){
        printf(“empty stack”) ;
        exit(-1) ;
    }else{
        tmp = s-&gt;Next-&gt;Next ;
        free(s-&gt;Next) ;
        s-&gt;Next = tmp ;
    }
}</p>

<p>void MakeEmpty(Stack s)
{
    if(!s){
        printf(“you must create stack first!”) ;
        exit(-1) ;
    }else{
        while(IsEmpty(s))
            Pop(s) ;
    }
}
```</p>

<p>2014年05月22日14:13:21</p>

<p>乐此不疲~</p>
