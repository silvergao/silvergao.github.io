<p>线性表ADT定义如下：</p>
<p>&gt;<br />
<span class="caps">ADT</span> 线性表 (List)<br />
Data<br />
Operation  <br />
    void initList(<strong>L);	//创建并初始化一个空线性表，如果成功返回true，修改表传指针   <br />
    bool listEmpty(L);	//判断一个线性表是否为空，不修改表传值   <br />
    void clearList(</strong>L);	//清空一个线性表，成功返回true   <br />
    bool getElem(L,i,<strong>e);	//从某个位置取出元素并赋值给e(i的范围是[1,L.length])，修改e的值所以传递一个指针，成功返回true  <br />
    int locateElem(L,e);	//查找线性表中是否有e，如果有返回它的位置(从1开始)，否则返回0表示失败  <br />
    bool listInsert(</strong>L,i,e);	//插入一个元素e在第i个元素之前(i的取值范围是[1,L.length+1]) ，成功返回true   <br />
    bool listDelete(<strong>L,i,</strong>e);	//删除在第i个位置上的元素(i的取值范围是[1,L.length]),删除的元素赋给e，成功返回true  <br />
    int listLength(L);	//返回线性表的元素个数  <br />
endADT</p>
<p>线性表有多种如下图：<br />
![Alt text](http://leihuang.qiniudn.com/2012_08_22_02.gif)</p>

	<ol>
		<li>顺序存储结构<br />
&gt;线性表的顺序存储结构，指的是用一段地址`连续的存储单元`依次存储线性表的数据元素。</li>
	</ol><p>根据线性表的特性，我们会想到用数组来实现它，直接上代码吧，这个多说无意，最好自己去实现一遍。</p>
<p>&gt;**注意**:你会发现函数中的参数虽然都是链表，但有的传得是指针，有的传的是链表本身，会发生这种情况取决于，c语言是按值传递。</p>
<p>&gt; &#8211; 当参数是L时，传到函数里面的并不是链表本身，而是他的一个复制品，所以这样会导致你无法修改链表<br />
&gt; &#8211; 当参数是*L时，则传到函数里面的是链表的地址，此时就可以通过地址来修改链表。</p>
<p>```c<br />
#include<stdio.h></p>
<p>#define OK 1<br />
#define <span class="caps">ERROR</span> 0<br />
#define <span class="caps">TRUE</span> 1<br />
#define <span class="caps">FALSE</span> 0<br />
#define <span class="caps">MAXSIZE</span> 20  /* 存储空间初始配量 */<br />
typedef int ElemType ; //可以自定义，这里假设为int<br />
typedef int Status ; //Status是函数的类型，其值是函数结果状态码</p>
<p>typedef struct <br />
{<br />
    ElemType data[<span class="caps">MAXSIZE</span>] ;<br />
    int length ;<br />
}SqList;</p>
<p>/* Operation <strong>/<br />
/</strong> 当需要修改表的时候传入的参数是*L，查看的时候函数参数为L，因为c是按值传递，不传指针则无法修改原本的链表 */<br />
void InitList(SqList *L) ;<br />
bool ListEmpty(SqList L) ;<br />
void ClearList(SqList *L) ;<br />
bool GetElem(SqList L,int i,ElemType *e) ;<br />
int LocateElem(SqList L,ElemType e) ;<br />
bool ListInsert(SqList *L,int i,ElemType e) ;<br />
bool ListDelete(SqList *L,int i,ElemType *e) ;<br />
void ListPrint(SqList L) ;</p>
<p>main()<br />
{<br />
    SqList L ;<br />
    InitList(&amp;L) ;<br />
    if(ListEmpty(L))<br />
        printf(&#8220;empty&#8221;) ;<br />
    ListInsert(&amp;L,1,1) ;</p>
int i ;
GetElem(L,1,&amp;i) ;
printf(&#8220;%d&#8221;,i) ;
printf(&#8220;%d&#8221;,LocateElem(L,1)) ;

ListPrint(L) ;
ListDelete(&amp;L,1,&amp;i) ;
ListPrint(L) ;
<p>}</p>
<p>/* 初始化顺序线性表 */<br />
void InitList(SqList *L)<br />
{<br />
    L&#8594;length = 0 ;<br />
}</p>
<p>bool ListEmpty(SqList L)<br />
{<br />
    return L.length==0 ;<br />
}</p>
<p>void ClearList(SqList *L)<br />
{<br />
    L&#8594;length = 0 ;<br />
}</p>
<p>/*在L中第i个位置之前插入新元素e，L的长度加1 */<br />
bool ListInsert(SqList *L,int i,ElemType e)<br />
{<br />
    int k ;<br />
    if(L&#8594;length==<span class="caps">MAXSIZE</span>||i&lt;1||i&gt;L&#8594;length+1)<br />
        return <span class="caps">ERROR</span> ;</p>
if(i&lt;=L&#8594;length)   //插入元素的位置不在表尾
{
for(k=L&#8594;length-1;k&gt;=i-1;++i)
L&#8594;data[k+1] = L&#8594;data[k] ;
}
L&#8594;data[i-1] = e ;
L&#8594;length++ ;
return OK ;
<p>}</p>
<p>bool GetElem(SqList L,int i,ElemType *e)<br />
{<br />
    if(i&lt;1||i&gt;L.length)<br />
        return <span class="caps">ERROR</span> ;<br />
   *e = L.data[i-1] ; <br />
   return OK ;<br />
}</p>
<p>int LocateElem(SqList L,ElemType e)<br />
{<br />
    int i ;<br />
    for(i=0;i&lt;L.length||L.data[i]e;++i)
        ;
    return iL.length?<span class="caps">ERROR</span>:i ;<br />
}</p>
<p>bool ListDelete(SqList <strong>L,int i,ElemType *e)<br />
{<br />
    int k;<br />
    if (L&#8594;length==0)               /</strong> 线性表为空 <strong>/<br />
    	return <span class="caps">ERROR</span>;<br />
    if (i &lt; 1 || i&gt;L&#8594;length)         /</strong> 删除位置不正确 <strong>/<br />
        return <span class="caps">ERROR</span>;<br />
    *e=L&#8594;data[i-1];<br />
    if (i &lt; L&#8594;length)                /</strong> 如果删除不是最后位置 <strong>/<br />
    {<br />
        for(k=i;k &lt; L&#8594;length; k++)/</strong> 将删除位置后继元素前移 */<br />
            L&#8594;data[k-1]=L&#8594;data[k];<br />
    }<br />
    L&#8594;length&#8212;;<br />
    return OK;<br />
}</p>
<p>void ListPrint(SqList L)<br />
{<br />
    if(L.length==0)<br />
        printf(&#8220;list is empty!&#8221;) ;<br />
    else<br />
    {<br />
	int i ;<br />
        for(i=0;i&lt;L.length;++i)<br />
	    printf(&#8220;%d&#8594;&#8221;,L.data[i]) ;<br />
    }<br />
}<br />
```</p>
<p>至此我们的顺序存储结构完成了，那么顺序存储有什么优缺点呢？<br />
&gt;**优点**：<br />
         具有简单、运算方便等优点，特别是对于小线性表或长度固定的线性表，采用顺序存储结构的优越性更为突出；</p>
<p>&gt;**缺点**：</p>
<p>&gt; 1. 顺序存储插入与删除一个元素，必须移动大了的数据元素，以此对大的线性表，特别是在元素的插入和删除很频繁的情况下，采取顺序存储很是不方便，效率低；<br />
2. 顺序存储空间容易满，出现上溢，程序访问容易出问题，顺序存储结构下，存储空间不便扩充；<br />
3. 顺序存储空间的分配问题，分多了浪费，分少了空间不足上溢。</p>
<p>由于顺序存储有这些缺点，于是我们就有了另外一种实现方式即`链式存储结构`。</p>

	<ol>
		<li>链式存储结构<br />
链式存储不再像顺序存储一样是连续的了，它们存储在内存中并不是连续的，通过指针来将他们相连。<br />
&gt;**区别**: 链式存储结构很好的解决了顺序存储结构插入和删除效率低的问题，但是他检索元素效率低。</li>
	</ol>
		<ol>
			<li>链表的基本概念<br />
- 数据域：我们把存储数据元素信息的域称为数据域。<br />
- 指针域：存储直接后继位置的域称为指针域。<br />
- 指针/链：指针域中存储的信息称做指针或链。<br />
- 结点(Node)：数据域与指针域这两部分信息组成数据元素ai的存储映像，称为结点(Node)</li>
		</ol><p>![image](http://leihuang.qiniudn.com/2012_08_30_03.jpg)</p>

		<ol>
			<li>头指针、头结点与首元结点<br />
对头指针概念的理解，这个很重要。“链表中第一个结点的存储位置叫做头指针”，如果链表有头结点，那么头指针就是指向头结点数据域的指针。画一个图吧。</li>
		</ol><p>![image](http://leihuang.qiniudn.com/2012_08_31_01.jpg)</p>
<p>- `头指针`: L存的地址是头结点的地址(如果头结点存在的话)，*L表示头结点值(头结点的数据为空)<br />
- `头结点`: 数据域为空，下一个元素即链表中第一个元素。<br />
- `首元结点`: 即图中的元素a1</p>
<p>下图是没有头结点的情况，(有没有完全看个人兴趣，不过建议最好有，因为我发现高手写的代码里面都存在头结点，这样可以保持程序的一致性。)</p>
<p>![image](http://leihuang.qiniudn.com/2012_08_31_02.jpg)</p>
<p>好的，理解了上面这点之后，here we go !</p>
<p>线性表链式实现：</p>
<p><b>linkedlist.h</b></p>
<p>```c<br />
#ifndef _List_H</p>
<p>struct Node ;<br />
typedef void* ElementType ;<br />
typedef struct Node *PtrToNode ;<br />
typedef PtrToNode List ;<br />
typedef PtrToNode Position ;</p>
<p>List InitList() ;<br />
List MakeEmpty(List L) ;<br />
int IsEmpty(List L) ;<br />
int IsLast(Position P,List L) ;<br />
Position Find(ElementType X,List L) ;<br />
Position FindPrevious(ElementType X,List L) ;<br />
void Delete(ElementType X,List L) ;<br />
void Insert(ElementType X,List L,Position P) ;<br />
void DeleteList(List L) ;<br />
Position Header(List L) ;<br />
Position First(List L) ;<br />
void PrintList(List L) ;<br />
#endif</p>
<p>struct Node<br />
{<br />
    ElementType Element ;<br />
    Position Next ;<br />
};<br />
```</p>
<p><b>linkedlist.c文件</b></p>
<p>```c<br />
#include<stdio.h><br />
#include<stdlib.h><br />
#include &#8220;List.h&#8221;<br />
main()<br />
{<br />
    int i = 1 ;<br />
    int j = 2 ;<br />
    int k = 3 ;</p>
List L = InitList() ;
Insert(&amp;i,L,L) ;
Insert(&amp;j,L,L&#8594;Next) ;
Insert(&amp;k,L,L&#8594;Next&#8594;Next) ;
//printf(&#8220;%d\n&#8221;,<strong>(int</strong>)First(L)&#8594;Element) ;
PrintList(L) ;
Delete(&amp;j,L) ;
PrintList(L) ;
DeleteList(L) ;
PrintList(L) ;
<p>}</p>
<p>List InitList()<br />
{    <br />
    List L = (List)malloc(sizeof(Node)) ;<br />
    if(!L){<br />
        printf(&#8220;out of space!&#8221;) ;<br />
        exit(-1) ;<br />
    }<br />
    L&#8594;Next = <span class="caps">NULL</span> ;<br />
    return L ;<br />
}<br />
int IsEmpty(List L) <br />
{<br />
   return L&#8594;Next == <span class="caps">NULL</span> ;<br />
}</p>
<p>int IsLast(Position P,List L) <br />
{<br />
    return P&#8594;Next == <span class="caps">NULL</span> ;<br />
}</p>
<p>Position Find(ElementType X,List L)<br />
{<br />
    Position P = L&#8594;Next ;<br />
    while(P<img src="NULL&amp;&amp;X" alt="" />=P&#8594;Element)<br />
        P = P&#8594;Next ;<br />
    return P ;<br />
}</p>
<p>//if X not exit ,return <span class="caps">NULL</span><br />
Position FindPrevious(ElementType X,List L)<br />
{<br />
    Position P = L ;<br />
    while(P&#8594;Next&#8594;Element<img src="X&amp;&amp;P" alt="" />=<span class="caps">NULL</span>)<br />
        P = P&#8594;Next ;<br />
    return P ;<br />
}</p>
<p>void Delete(ElementType X,List L)<br />
{<br />
    Position P ,TempPo ;<br />
    P = FindPrevious(X,L) ;<br />
    if(P)            //if X not exit P = <span class="caps">NULL</span><br />
    {<br />
       TempPo = P&#8594;Next ;<br />
       P&#8594;Next = TempPo&#8594;Next ;<br />
       free(TempPo) ;<br />
    }<br />
}</p>
<p>//insert X to P&#8217;s back<br />
void Insert(ElementType X,List L,Position P)<br />
{<br />
    Position TempPo ;<br />
    TempPo = (Node*)malloc(sizeof(struct Node)) ;<br />
    if(TempPo == <span class="caps">NULL</span>){<br />
        printf(&#8220;out of space!!!&#8221;) ;<br />
        exit(-1);<br />
    }<br />
    TempPo&#8594;Element = X ;<br />
    TempPo&#8594;Next = P&#8594;Next ;<br />
    P&#8594;Next = TempPo ;<br />
}</p>
<p>void DeleteList(List L)<br />
{<br />
    Position P,Tmp ;<br />
    P = L&#8594;Next ;<br />
    L&#8594;Next = <span class="caps">NULL</span> ;</p>
while(P!=<span class="caps">NULL</span>)
{
Tmp = P&#8594;Next ;          //notice
free(P) ;
P = Tmp ;
}
<p>}</p>
<p>Position Header(List L)<br />
{<br />
    return L ;<br />
}</p>
<p>Position First(List L)<br />
{<br />
    return L&#8594;Next ;<br />
}</p>
<p>void PrintList(List L)<br />
{<br />
    if(IsEmpty(L)){<br />
        printf(&#8220;list is empty!&#8221;) ;<br />
        exit(-1) ;<br />
    }<br />
    Position pCurrent ;<br />
    pCurrent = L&#8594;Next ;<br />
    while(pCurrent){<br />
        printf(&#8220;%d&#8594;&#8221;,<strong>(int</strong>)pCurrent&#8594;Element) ;<br />
        pCurrent = pCurrent&#8594;Next ;<br />
    }<br />
    printf(&#8220;\n&#8221;) ;<br />
}<br />
```</p>

	<ol>
		<li>循环链表<br />
![image](http://leihuang.qiniudn.com/cyclelist.png)</li>
	</ol>